/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from "workbox-core";
import { ExpirationPlugin } from "workbox-expiration";
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import { StaleWhileRevalidate } from "workbox-strategies";

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp("/[^/?]+\\.[^/]+$");
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== "navigate") {
      return false;
    } // If this is a URL that starts with /_, skip.

    if (url.pathname.startsWith("/_")) {
      return false;
    } // If this looks like a URL for a resource, because it contains // a file extension, skip.

    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    } // Return true to signal that we want to use the handler.

    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + "/index.html")
);

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) =>
    url.origin === self.location.origin && url.pathname.startsWith("/images/"), // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: "images",
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener("message", (event) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  }
});

// Function to get all image URLs dynamically from manifest
const getImageUrls = async () => {
  try {
    console.log("üîç Fetching images manifest...");
    const response = await fetch("/images-manifest.json");

    if (response.ok) {
      const manifest = await response.json();
      console.log(
        `üìã Found ${
          manifest.totalImages || manifest.images.length
        } images in manifest`
      );
      return manifest.images || [];
    } else {
      console.warn("‚ö†Ô∏è Images manifest not found, using fallback");
    }
  } catch (error) {
    console.warn("‚ö†Ô∏è Could not fetch images manifest:", error.message);
  }

  // Fallback ke daftar default jika manifest tidak tersedia
  const fallbackImages = [
    "/images/product-1.jpg",
    "/images/product-2.jpg",
    "/images/product-3.jpg",
    "/images/product-4.jpg",
    "/images/product-5.jpg",
    "/images/product-6.jpg",
  ];

  console.log("üìã Using fallback image list");
  return fallbackImages;
};

// Function to cache images with progress tracking
const cacheImages = async () => {
  try {
    console.log("üöÄ Starting image caching process...");
    const cache = await caches.open("images");
    const imageUrls = await getImageUrls();

    if (imageUrls.length === 0) {
      console.log("üì≠ No images to cache");
      return;
    }

    // Check which images are not already cached
    const uncachedImages = [];
    console.log("üîç Checking existing cache...");

    for (const url of imageUrls) {
      const response = await cache.match(url);
      if (!response) {
        uncachedImages.push(url);
      }
    }

    // Cache only uncached images
    if (uncachedImages.length > 0) {
      console.log(`üì• Caching ${uncachedImages.length} new images...`);

      // Cache images one by one with error handling
      const results = await Promise.allSettled(
        uncachedImages.map(async (url) => {
          try {
            const response = await fetch(url);
            if (response.ok) {
              await cache.put(url, response);
              console.log(`‚úÖ Cached: ${url}`);
              return { url, success: true };
            } else {
              console.warn(`‚ö†Ô∏è Failed to fetch: ${url} (${response.status})`);
              return { url, success: false, error: `HTTP ${response.status}` };
            }
          } catch (error) {
            console.error(`‚ùå Error caching ${url}:`, error.message);
            return { url, success: false, error: error.message };
          }
        })
      );

      // Report results
      const successful = results.filter((r) => r.value?.success).length;
      const failed = results.length - successful;

      console.log(
        `üìä Caching complete: ${successful} successful, ${failed} failed`
      );

      if (failed > 0) {
        console.warn(
          "‚ùå Failed images:",
          results.filter((r) => !r.value?.success).map((r) => r.value?.url)
        );
      }
    } else {
      console.log("‚úÖ All images are already cached");
    }

    // Report final cache status
    const allCachedImages = await cache.keys();
    const imagesCached = allCachedImages.filter((req) =>
      req.url.includes("/images/")
    ).length;
    console.log(`üì¶ Total images in cache: ${imagesCached}`);
  } catch (error) {
    console.error("‚ùå Failed to cache images:", error);
  }
};

// Cache images during service worker installation (pre-cache)
self.addEventListener("install", (event) => {
  console.log("üîß Service Worker installing...");
  event.waitUntil(
    Promise.all([
      // Cache essential images first
      cacheImages(),
      // Precache other critical resources
      caches.open("app-shell").then((cache) => {
        return cache.addAll([
          "/",
          "/static/css/main.css", // Adjust based on your build output
          "/static/js/main.js", // Adjust based on your build output
          "/manifest.json",
          "/favicon.ico",
        ]);
      }),
    ])
      .then(() => {
        console.log("‚úÖ All critical resources cached during installation");
        return self.skipWaiting();
      })
      .catch((error) => {
        console.error("‚ùå Error during installation:", error);
        // Continue with installation even if caching fails
        return self.skipWaiting();
      })
  );
});

// Cache images when main page is accessed (runtime cache)
self.addEventListener("fetch", (event) => {
  const url = new URL(event.request.url);
  const isMainPage = url.pathname === "/" || url.pathname === "/index.html";

  // Check if this is a navigation request to the main page
  if (isMainPage && event.request.mode === "navigate") {
    console.log("üè† Main page accessed, checking image cache...");
    // Cache images in the background without blocking the main request
    event.waitUntil(
      cacheImages().catch((error) => {
        console.error("‚ùå Background image caching failed:", error);
      })
    );
  }
});

// Activate event - clean up old caches if needed
self.addEventListener("activate", (event) => {
  console.log("üéØ Service Worker activated");
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      // Clean up old image caches if needed
      return Promise.all(
        cacheNames.map((cacheName) => {
          // Keep current image cache and workbox caches
          if (
            cacheName.startsWith("images-old-") ||
            (cacheName.includes("images") && cacheName !== "images")
          ) {
            console.log(`üóëÔ∏è Deleting old cache: ${cacheName}`);
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});

// Any other custom service worker logic can go here.
